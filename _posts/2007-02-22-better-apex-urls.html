---
layout: post
title: Better APEX urls
date: '2007-02-22T22:00:00.000-08:00'
author: Kris Rice
tags: 
modified_time: '2007-02-22T22:03:17.117-08:00'
blogger_id: tag:blogger.com,1999:blog-37621059.post-2844702767420204752
blogger_orig_url: http://krisrice.blogspot.com/2007/02/better-apex-urls.html
---

<p style="text-indent:20pt;">I was cleaning up a webserver and found this code I wrote a few years ago to help make HTMLDB now Application Express entry points nicer.   Hopefully everyone knows Application Express and uses it everyday, if not you should go sign up and kick the tires at <a href="http://apex.oracle.com">apex.oracle.com</a>.  Prior to working on SQL Developer, I did some work in Application Express and built some internal systems with <a href="http://carlback.blogspot.com/">Carl</a> and others.  One issue I had was an easy way to map a url to an application in order to make the entry point nice and easy like http://myapp.mycompany.com which really point to http://apex.oracle.com/pls/otn/f?p=MYAPP:MYPAGE</p><p style="text-indent:20pt;">Now you may think just a simple Apache re-write would solve this and you'd be correct but I had to add multiple re-write and didn't want to bounce Apache in order to add new ones or change existing ones.  So the answer was in mod_perl.  What I did was make a mapping file as follows:</p><pre><br />  mycompany.com;/pls/apex/f?p=3701:1<br />  internal.mycompany.com;/pls/apex/f?p=3701:1<br />  yourcompany.com;/pls/apex/f?p=111:1<br />  /path;/pls/apex/f?p=1:1<br /></pre><p style="text-indent:20pt;">You can see from the mapping file that it's fairly flexible.  You can map /myapp or myapp.mycompany.com.  The best part about this solution is that the perl code below re-reads the file every 5 minutes in case you added more mappings and no bounce of apache.</p><p style="text-indent:20pt;">These 2 lines will have to be placed early in the httpd.conf so it can have the opportunity to look at all the incoming request.  Here's the 2 lines needed to change in the httpd.conf file</p><pre>PerlModule HTMLDB::VirtualServer<br />PerlTransHandler HTMLDB::VirtualServer<br /></pre><p style="text-indent:20pt;">This code will have to be adjusted for location of the config file and maybe you'll adjust the reloading of the file but it should mostly work.  This file will have to be placed into the perl library path with something like this:</p><pre>SetEnv PERL5LIB  "/mypath/to/the/path"<br /><br /></pre><pre>package HTMLDB::VirtualServer;<br />#<br />#<br /># Apache httpd.conf entry<br /># PerlModule HTMLDB::VirtualServer<br /># PerlTransHandler HTMLDB::VirtualServer<br />#<br />#<br /># Sample config file<br />#mycompany.com;/pls/apex/f?p=3701:1<br />#internal.mycompany.com;/pls/apex/f?p=3701:1<br />#yourcompany.com;/pls/apex/f?p=111:1<br />#/path;/pls/apex/f?p=1:1<br />#<br />#<br />  use Apache::Constants qw(REDIRECT DECLINED); <br />  use strict;<br />  # path to config file<br />  my $configfile = "/export/home/oracle/HTMLDB/htmldbvirtual.conf";<br />  my $debug = 0;<br />  my $lastLoad;<br />  my %names = ();<br /><br /><br /># simple routine to see what's going on<br />sub logMe{<br />   my $logLine = shift;<br />   if ( $debug eq 1 ) {<br /></pre><pre>  # log file if $debug = 1<br /></pre><pre>     open(L,'&gt;&gt;/tmp/htmldbvirtual.log');<br />     print L $logLine;<br />     close L;<br />  }<br />}<br />  <br /># load the config file  <br />sub loadConfigFile{<br />  my $now = time;apex/home<br />  # cache the config for 5 minutes then reload<br />  if ( ( $now - $lastLoad ) &gt; 600 ) {<br />    open CONF,$configfile;<br />    my $name;<br />    my $uri;<br />    while (){<br />      chomp;<br />        ($name,$uri) = split /;/;<br />          $names{$name} = $uri;<br />    }<br />    $lastLoad = time;<br />      if ( $debug) {<br />        while ( my ($key, $value) = each(%names) ) { logMe( "L:$key =&gt; $value\n"); }<br />       }<br />  }<br />   %names;<br /> }<br /><br /><br /> sub handler {<br />      my $r = shift;<br />      my %names = loadConfigFile();<br />      logMe("Request:" . $r-&gt;uri . "\n");<br /><br />     if  (  $r-&gt;uri eq "/" <br />            ||  $r-&gt;uri eq "/index.html" <br />            ||  ( length($names{$r-&gt;uri}) &gt; 0 ||  length($names{$r-&gt;uri."/index.html"} ) &gt; 0 )  ) {<br />            	<br />      # grab vars for use.<br />      my $s = $r-&gt;server();<br />      my $hostname = $r-&gt;hostname();<br />      my %args = $r-&gt;args;<br />      my $base =  $s-&gt;port() == 443 ? "https://" : "http://";<br /><br />      if ( length($hostname) &gt; 0 ) {<br />        $base = $base . $hostname;<br />      } else {<br />        $base = $base . $s-&gt;server_hostname();<br />      }<br /><br />      if ( $s-&gt;port() != 80 &#38;&#38; $s-&gt;port() != 443 )  {<br />       $base = $base . ":" . $s-&gt;port();<br />      }<br />      logMe($base . "\n");<br /><br />      my $key = length($names{$r-&gt;uri} ) &gt; 0 ? $r-&gt;uri : $hostname ;<br /><br />      if (  length($names{$key} ) &gt; 0<br />          &#38;&#38; ! $args {"p"} ) {<br />           #$r-&gt;header_out(Location =&gt; $base . $hostname );<br />           $r-&gt;header_out(Location =&gt; $base . $names{$key} );<br /><br />         logMe("HTMLDB::VirtualServer:". $base .  $names{$key} . "\n");<br />         return REDIRECT; # means we did a redirect<br />      }<br />   }<br />         return DECLINED; # means we did not handle the request<br />  }<br />1;<br /></pre>