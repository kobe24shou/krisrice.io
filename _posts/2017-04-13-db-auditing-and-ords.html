---
layout: post
title: 'DB Auditing and ORDS '
date: '2017-04-13T06:09:00.002-07:00'
author: Kris Rice
tags: 
modified_time: '2017-04-13T06:09:35.326-07:00'
thumbnail: https://1.bp.blogspot.com/-CJuX1QQc6JQ/WO91ntjNK7I/AAAAAAAABO4/W8bMGLaY6MclG_16PwewYmsj261H4QsZACK4B/s72-c/Screen%2BShot%2B2017-04-13%2Bat%2B8.56.47%2BAM.png
blogger_id: tag:blogger.com,1999:blog-37621059.post-1411905273496018932
blogger_orig_url: http://krisrice.blogspot.com/2017/04/db-auditing-and-ords.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">There seems to be some confusion around how ORDS works with it's connection pooling yet running the REST call as the specified schema.<br /><br /><h3 style="text-align: left;">The connection pool</h3>Consider a 50 PDB env and concurrent users per PDB running some REST stuff. &nbsp;Using a connection pool per PDB would be 50 connection pools. &nbsp;Then if a JET app ( or any HTML5/JS/.. ) is making REST calls Chrome will do this with 6 concurrent calls. &nbsp;This makes it so that as simple as 5 concurrent users * 6 threads in Chrome * 50 PDBs would reach 1500 connections.<br /><br />For this reason, in a CDB install the connection pool is established as a common user in the CDB names ORDS_PUBLIC_USER. &nbsp;This allows for common connection pool that can be shared over all 50 PDBs. &nbsp;As requested finish, the connection can be recycled back for any PDB to service the next request.<br /><br /><br /><h3 style="text-align: left;">What about Auditing&nbsp;</h3>This is where the confusion begins. &nbsp;If it's a common connection pool, it's un-auditable. FALSE<br /><br />I made a trivial REST api that does nothing more than a select on EMP<br /><br /><a href="http://1.bp.blogspot.com/-CJuX1QQc6JQ/WO91ntjNK7I/AAAAAAAABO4/W8bMGLaY6MclG_16PwewYmsj261H4QsZACK4B/s1600/Screen%2BShot%2B2017-04-13%2Bat%2B8.56.47%2BAM.png" imageanchor="1"><img border="0" height="342" src="https://1.bp.blogspot.com/-CJuX1QQc6JQ/WO91ntjNK7I/AAAAAAAABO4/W8bMGLaY6MclG_16PwewYmsj261H4QsZACK4B/s400/Screen%2BShot%2B2017-04-13%2Bat%2B8.56.47%2BAM.png" width="400" /></a><br /><br /><br />Then I turned on Auditing of this table with the following<br /><br /><br /><pre class="brush:sql">AUDIT SELECT, INSERT, DELETE<br />     ON klrice.emp<br />     BY ACCESS<br />     WHENEVER SUCCESSFUL;<br />     <br /></pre>Running the REST call and checking the DB level audit results in exactly what is expected. &nbsp;There's no notion of the common ORDS_PUBLIC_USER anywhere. &nbsp;The user KLRICE accessed this table making all normal DB auditing work well normal.<br /><br /><br /><a href="http://4.bp.blogspot.com/-tQwKboUbGBo/WO92XsYclmI/AAAAAAAABPE/q_rdYdZd7pMoJdfpcoJlzZ4bBCQS2PmNQCK4B/s1600/Screen%2BShot%2B2017-04-13%2Bat%2B8.58.27%2BAM.png" imageanchor="1"><img border="0" height="218" src="https://4.bp.blogspot.com/-tQwKboUbGBo/WO92XsYclmI/AAAAAAAABPE/q_rdYdZd7pMoJdfpcoJlzZ4bBCQS2PmNQCK4B/s640/Screen%2BShot%2B2017-04-13%2Bat%2B8.58.27%2BAM.png" width="640" /></a><br /><br /><br /><h3 style="text-align: left;">Then why all the FUD?</h3>I think the confusion is that APEX using a different mechanism than ORDS for executing the user's sql with the parse_as options. &nbsp;When run like this the object audit log shows that the common APEX_PUBLIC_USER is the user that accessed the object and the parse_as user of KLRICE in this case is not present. &nbsp;However, APEX does populate the CLIENT ID so the audit trail has the runtime user that accessed the object.<br /><br /><br /><a href="http://4.bp.blogspot.com/-ZP7nKW-YZzA/WO94WLIu2jI/AAAAAAAABPc/pyTNgjXyEicdV8j8KuQkYrbpy9X9dT8WACK4B/s1600/Screen%2BShot%2B2017-04-13%2Bat%2B9.06.55%2BAM.png" imageanchor="1"><img border="0" height="198" src="https://4.bp.blogspot.com/-ZP7nKW-YZzA/WO94WLIu2jI/AAAAAAAABPc/pyTNgjXyEicdV8j8KuQkYrbpy9X9dT8WACK4B/s640/Screen%2BShot%2B2017-04-13%2Bat%2B9.06.55%2BAM.png" width="640" /></a><br /><br /><br /><br /></div>