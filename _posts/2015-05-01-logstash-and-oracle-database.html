---
layout: post
title: Logstash and Oracle Database
date: '2015-05-01T12:04:00.001-07:00'
author: Kris Rice
tags: 
modified_time: '2016-03-30T05:48:27.416-07:00'
thumbnail: https://3.bp.blogspot.com/-4hOXlcrb0GE/VUPLgr6bkDI/AAAAAAAAA8Y/iBogDcvnW6I/s72-c/Screen%2BShot%2B2015-05-01%2Bat%2B14.52.34.png
blogger_id: tag:blogger.com,1999:blog-37621059.post-5056261798106693500
blogger_orig_url: http://krisrice.blogspot.com/2015/05/logstash-and-oracle-database.html
---

&nbsp; &nbsp; For anyone that doesn't know what Logstash is head over to <a href="http://logstash.net/">http://logstash.net/</a>&nbsp;and watch the video on the home page. &nbsp;Robin Moffatt has done a great <a href="http://www.rittmanmead.com/2014/10/monitoring-obiee-with-elasticsearch-logstash-and-kibana/">blog post</a> on the full ELK stack with OBIEE.<br /><br />&nbsp; &nbsp; This blog post is a first cut at an input filter for Logstash to gather metrics, logs, or anything that can be expressed in sql. &nbsp;A huge caution that this is a 0.01 attempt and will get better as I need it to. &nbsp;This is a basic config of doing a select sessions every 5 seconds and report that in this case to just STDOUT. &nbsp;There are many choices of where to send this information like to elastic search for visualization into Kibana as Mark showed in the OBIEE example.<br /><br />&nbsp; &nbsp; If anyone uses this, changes it, likes it, doesn't like it, &nbsp;let me know.<br /><br /><pre class="brush: shell;">input { <br />  orasql { sql      =&gt; "SELECT count(1) sessions from v$session "<br />           dbuser   =&gt; "klrice"<br />           dbpasswd =&gt; "klrice"<br />           dburl    =&gt; "localhost/orcl"<br />           interval =&gt;  5<br />      } <br />}<br />output {<br /> stdout { codec =&gt; rubydebug }<br />}<br /></pre><br />The running of this is just needs to add in the plugin path for be able to find the orasql input filter.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-4hOXlcrb0GE/VUPLgr6bkDI/AAAAAAAAA8Y/iBogDcvnW6I/s1600/Screen%2BShot%2B2015-05-01%2Bat%2B14.52.34.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="495" src="https://3.bp.blogspot.com/-4hOXlcrb0GE/VUPLgr6bkDI/AAAAAAAAA8Y/iBogDcvnW6I/s1600/Screen%2BShot%2B2015-05-01%2Bat%2B14.52.34.png" width="640" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div>&nbsp; &nbsp; &nbsp;The filter itself is where everything oracle-wise is happening. &nbsp;Since Logstash is written in JRuby, I'm able to use the normal Oracle JDBC Driver to access the database. &nbsp;For this case I have a ./lib folder where I have a local copy. &nbsp;This could just as easily be $ORACLE_HOME/jdbc/lib/ojdbc6.jar to ensure using the same as the database version when on the same server.<br /><br />&nbsp; &nbsp; &nbsp;Since the connect and establishing a session is expensive when repeatedly issuing sql, I have kept a connection open. &nbsp;The connection could be closed for any number of reasons so there's an auto-reconnect in here also by calling the getConnection before any sql exec. &nbsp; Before someone asks: no, sqldev will not get an auto-reconnect like this. <br /><br /><br /><br /><br /><pre class="brush: shell;"># encoding: utf-8<br />require "logstash/inputs/base"<br />require "logstash/namespace"<br />require "socket" # for Socket.gethostname<br />require 'java'<br /><span style="color: red;"># SETUP THE JDBC DRIVER TO YOUR LOCATION<br />$CLASSPATH &lt;&lt; "lib/ojdbc6.jar"</span><br /><br />java_import 'oracle.jdbc.OracleDriver'<br />java_import 'java.sql.DriverManager'<br /><br /><br /># Run sql line tools and capture the whole output as an event.<br />#<br /># Notes:<br />#<br /># * The '@source' of this event will be the sql run.<br /># * The '@message' of this event will be the entire stdout of the sql<br />#   as one event.<br />#<br />class LogStash::Inputs::OraSQL &lt; LogStash::Inputs::Base<br /><br />  config_name "orasql"<br />  milestone 2<br />   <br />  $currConnection = nil<br /><br />  default :codec, "plain"<br /><br />  # Set this to true to enable debugging on an input.<br />  config :debug, :validate =&gt; :boolean, :default =&gt; false, :deprecated =&gt; "This setting was never used by this plugin. It will be removed soon."<br /><br />  # SQL to run. For example, "select * from emp"<br />  config :sql, :validate =&gt; :string, :required =&gt; true<br /><br />  # dbuser to run. For example, "select * from emp"<br />  config :dbuser, :validate =&gt; :string, :required =&gt; true ,  :default =&gt; "/"<br /><br />  # dbpass to run. For example, "select * from emp"<br />  config :dbpasswd, :validate =&gt; :string, :required =&gt; false , :default =&gt; ""<br /><br />  # dburl to run. For example, "select * from emp"<br />  config :dburl, :validate =&gt; :string, :required =&gt; true , :default =&gt; "//localhost/orcl"<br /><br />  # Interval to run the sql. Value is in seconds.<br />  config :interval, :validate =&gt; :number, :required =&gt; true , :default =&gt; 120<br /><br />  public<br />  def register<br />    @logger.info("Registering SQL Input", :type =&gt; @type,<br />                 :sql =&gt; @sql, :interval =&gt; @interval)<br />  end # def register<br />  <br />  public <br />  def getConnection<br />      if $currConnection == nil  or  ! $currConnection.isValid(100)  <br />           oradriver = OracleDriver.new<br />           DriverManager.registerDriver oradriver<br /><br />           con_props = java.util.Properties.new<br />           con_props.setProperty("user", @dbuser)<br />           con_props.setProperty("password", @dbpasswd )<br /> <br />           conn =  Java::oracle.jdbc.OracleDriver.new.connect('jdbc:oracle:thin:@' + @dburl, con_props)<br /><br />           conn.auto_commit = false<br /><br />           $currConnection = conn<br />      end <br />      <br />      return $currConnection  <br />       <br />  end # end getConnection<br /><br />  public<br />  def run(queue)<br />    hostname = Socket.gethostname<br />   <br />    loop do<br />      start = Time.now<br />      @logger.info? &amp;&amp; @logger.info("Running SQL", :sql =&gt; @sql)<br /><br />      conn = getConnection<br /><br />      stmt = conn.prepare_statement @sql<br />      rset = stmt.execute_query<br />      while ( rset.next )<br />         i=1<br />         event =  event = LogStash::Event.new<br />         decorate(event)<br />         cols = rset.getMetaData.getColumnCount<br />         msg = ""<br />         r=0<br />         while ( i &lt;= cols ) <br />             val = rset.getString(i)<br />             if ( val != nil ) <br />                if ( r &gt; 0 )<br />                   msg = msg + ","<br />                end<br />                event[ rset.getMetaData.getColumnName(i).downcase ] =  val<br />                msg = msg +  "\"" +rset.getMetaData.getColumnName(i).downcase +  "\" : \"" + val + "\"" <br />                r=r+1<br />             end<br />             i = i + 1<br />         end<br />         event['message'] = "{" + msg + "}"<br />        queue &lt;&lt; event<br />      end<br />      conn.close<br /><br />      duration = Time.now - start<br />      @logger.info? &amp;&amp; @logger.info("Command completed", :sql =&gt; @sql,<br />                                    :duration =&gt; duration)<br /><br />      # Sleep for the remainder of the interval, or 0 if the duration ran<br />      # longer than the interval.<br />      sleeptime = [0, @interval - duration].max<br />      if sleeptime == 0<br />        @logger.warn("Execution ran longer than the interval. Skipping sleep.",<br />                     :sql =&gt; @sql, :duration =&gt; duration,<br />                     :interval =&gt; @interval)<br />      else<br />        sleep(sleeptime)<br />      end<br />    end # loop<br />  end # def run<br />end # class LogStash::Inputs::OraSQL<br /><br /></pre><br /><br /><br /><br />