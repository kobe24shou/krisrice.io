---
layout: post
title: Tailing work in the db as it run with pipes
date: '2013-08-08T08:41:00.000-07:00'
author: Kris Rice
tags: 
modified_time: '2013-08-08T08:50:26.409-07:00'
blogger_id: tag:blogger.com,1999:blog-37621059.post-4998854486826376191
blogger_orig_url: http://krisrice.blogspot.com/2013/08/tailing-work-in-db-as-it-run-with-pipes.html
---

&nbsp; Doesn't seem that long ago, I needed to monitor a process as it ran. &nbsp;So, I wrote a small wrapper over dbms_pipe to look like dbms_output so it was easy to switch back and forth. &nbsp;That was in 2004 so the file's timestamp says. &nbsp;Time flies ! <br /><br />&nbsp; DBMS_PIPE is nothing new and many have blogged it's good and bad. &nbsp;There's lots more but here's just a few:<br /><br /><a href="http://thinkoracle.blogspot.com/2005/11/dbmspipe.html">http://thinkoracle.blogspot.com/2005/11/dbmspipe.html</a><br /><br /><a href="http://www.hoekstra.co.uk/index.php/software-mainmenu-36/oracle-mainmenu-54/29-dbmspipe.html">http://www.hoekstra.co.uk/index.php/software-mainmenu-36/oracle-mainmenu-54/29-dbmspipe.html</a><br /><br /><a href="http://www.jaredstill.com/content/debug-pipe.html">http://www.jaredstill.com/content/debug-pipe.html</a><br /><br />&nbsp; Here's the wrapper I <a href="https://dl.dropboxusercontent.com/u/12188201/sqldev/pipe_output.pks">made</a>&nbsp;and the body is <a href="https://dl.dropboxusercontent.com/u/12188201/sqldev/pipe_output.pkb">here</a>:<br /><br /><br /><pre class="brush:sql">CREATE OR REPLACE PACKAGE pipe_output IS<br />   pv_pipe_on_bln BOOLEAN := false;<br />   PROCEDURE set_pipeoutput_on;<br /><br />   PROCEDURE put_line (p_message_txt VARCHAR2);<br />   PROCEDURE put_line (p_pipe_name VARCHAR2,p_message_txt VARCHAR2);<br />   <br />   PROCEDURE get_line (p_waittime_num NUMBER := 1);<br />   PROCEDURE get_line (p_pipe_name VARCHAR2,p_waittime_num NUMBER := 1);<br />   PROCEDURE get_line (p_pipe_name IN VARCHAR2,p_waittime_num IN NUMBER := 1,p_message OUT VARCHAR2);<br />END pipe_output;<br /></pre><br />So what that would allow me to do in the plsql block was something like this.<br /><br /><pre class="brush:sql;">begin<br />   pipe_output.set_pipeoutput_on;<br />  for r in ( select object_name from user_objects ) loop<br />    pipe_output.put_line('TAIL_ME',r.object_name);<br />  end loop;<br />end;<br /><br /></pre><br />Now that something is in the pipe it's time to get it out.  For that I wrote a small java <a href="https://dl.dropboxusercontent.com/u/12188201/sqldev/TailDBMSPipe.java">program</a>. &nbsp;The same thing can be done direct from a sqlplus script or perl or whatever, it's not complicated.<br /><br /><pre class="brush:java;">import java.math.BigDecimal;<br />import java.sql.CallableStatement;<br />import java.sql.Connection;<br />import java.sql.DriverManager;<br />import java.sql.Types;<br /><br />public class TailDBMSPipe extends Thread {<br />    private String v_pipe_name;<br />    private String connName;<br /><br />    public TailDBMSPipe(String pipeName) {<br />        super.setDaemon(true);<br />        v_pipe_name = pipeName;<br />    }<br /><br />    public static void main(String[] args) {<br />        TailDBMSPipe p = new TailDBMSPipe(args[0]);<br />        p.connName = "jdbc:oracle:thin:" + args[1];<br />        //p.connName = "jdbc:oracle:thin:my_customers/oracle@ap6002wgs.us.oracle.com:1521:mcdev";<br />        p.run();<br />    }<br /><br />    public void run() {<br />        System.out.println("Redirecting database pipe:" + v_pipe_name);<br />        Connection conn = null;<br /><br />        try {<br />            Class.forName("oracle.jdbc.driver.OracleDriver");<br />            conn = DriverManager.getConnection(connName);<br /><br />            String s = null;<br />            BigDecimal retVal;<br />            BigDecimal bigZero = new BigDecimal(0);<br /><br />            while (true) {<br />                CallableStatement cs = conn.prepareCall("{ call ? := DBMS_PIPE.RECEIVE_MESSAGE(?, ?) }");<br />                cs.registerOutParameter(1, Types.INTEGER);<br />                cs.setString(2, v_pipe_name);<br />                cs.setString(3, "100");<br />                cs.executeUpdate();<br />                retVal = cs.getBigDecimal(1);<br />                cs.close();<br /><br />                if (retVal.compareTo(bigZero) == 0) {<br />                    cs = conn.prepareCall("{ call DBMS_PIPE.UNPACK_MESSAGE( ?) }");<br />                    cs.registerOutParameter(1, Types.VARCHAR);<br />                    cs.executeUpdate();<br />                    s = cs.getString(1);<br />                    cs.close();<br /><br />                    if (s != null) {<br />                        System.out.println(v_pipe_name + ":" + s);<br />                    }<br />                }<br />            }<br />        } catch (Exception e) {<br />            e.printStackTrace();<br />            try {<br />                conn.close();<br />            } catch (Exception ex) {<br />                System.out.println("could not close");<br />            }<br />        }<br />    }<br />}<br /></pre><br /><br /><br />The results is that you can watch what comes across the pipe very fast. &nbsp;You may notice the timestamps in the output of what's in the demo here:<br /><br /><video id="movie" controls src="https://dl.dropboxusercontent.com/u/12188201/sqldev/PipeExample.mov"><br /></video>