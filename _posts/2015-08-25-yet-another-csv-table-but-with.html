---
layout: post
title: Yet another CSV -> Table but with pipleline function
date: '2015-08-25T07:10:00.003-07:00'
author: Kris Rice
tags: 
modified_time: '2015-08-25T07:11:01.937-07:00'
thumbnail: http://4.bp.blogspot.com/-EdEUGhr_Clw/Vdx1dJTEdqI/AAAAAAAABEc/5kzaJcQM-yU/s72-c/Screen%2BShot%2B2015-08-25%2Bat%2B10.01.12.png
blogger_id: tag:blogger.com,1999:blog-37621059.post-8030410788953600065
blogger_orig_url: http://krisrice.blogspot.com/2015/08/yet-another-csv-table-but-with.html
---

Here's just one more variation on how to get a CSV into a table format. &nbsp;It could have been done before but my google-fu couldn't find it anywhere.<br /><br />First to get some sample data using the /*csv*/ hint in sqldev.<br /><br /><br /><div class="separator" style="clear: both; text-align: left;"><a href="http://4.bp.blogspot.com/-EdEUGhr_Clw/Vdx1dJTEdqI/AAAAAAAABEc/5kzaJcQM-yU/s1600/Screen%2BShot%2B2015-08-25%2Bat%2B10.01.12.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-EdEUGhr_Clw/Vdx1dJTEdqI/AAAAAAAABEc/5kzaJcQM-yU/s1600/Screen%2BShot%2B2015-08-25%2Bat%2B10.01.12.png" /></a></div><br /><br />Then the results of putting it back to a table. The inline plsql is just to convert the text into a CLOB.<br /><br /><div class="separator" style="clear: both; text-align: left;"><a href="http://3.bp.blogspot.com/-tBQh0auuEpI/Vdx1yOI1C2I/AAAAAAAABEk/k3PhkoM7sMw/s1600/Screen%2BShot%2B2015-08-25%2Bat%2B10.03.26.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-tBQh0auuEpI/Vdx1yOI1C2I/AAAAAAAABEk/k3PhkoM7sMw/s1600/Screen%2BShot%2B2015-08-25%2Bat%2B10.03.26.png" /></a></div><br /><br />Now the details.<br /><br />The csv parsing is completely borrowed(stolen) from another Chris where he create a csv parser in plsql <a href="https://christopherbeck.wordpress.com/2012/04/03/parsing-a-csv-file-in-plsql/">here</a>.<br /><br />The changes I made which is probably obvious to use a plsql object and table of said object to put into a form that can be use in sql.<br /><br /><br />I'm sure there's optimizations that could be added in here since I almost never use plsql object. But here's the code that renders the above results.<br /><br /><br /><br /><pre class="brush:sql;">drop function parse_csv;<br />drop type t_csv_col;<br />drop type t_csv_table;<br /><br />CREATE OR REPLACE TYPE t_csv_table IS OBJECT<br />(<br />    col1   varchar2(4000),<br />    col2   varchar2(4000),<br />    col3   varchar2(4000),<br />    col4   varchar2(4000),<br />    col5   varchar2(4000),<br />    col6   varchar2(4000),<br />    col7   varchar2(4000),<br />    col8   varchar2(4000),<br />    col9   varchar2(4000),<br />    col10   varchar2(4000)<br />)<br />/<br /><br />show errors<br /><br />CREATE or replace TYPE t_csv_COL IS TABLE OF t_csv_table<br />/<br /><br />show errors<br /><br /><br /><br />create or replace function parse_csv(<br />  p_clob clob,<br />  p_delim varchar2 default ',',<br />  p_optionally_enclosed varchar2 default '"' ) <br />  return t_csv_COL<br />  <br />  is<br />  --<br />  CARRIAGE_RETURN constant char(1) := chr(13);<br />  LINE_FEED constant char(1) := chr(10);<br />  --<br />  l_char char(1);<br />  l_lookahead char(1);<br />  l_pos number := 0;<br />  l_token varchar2(32767) := null;<br />  l_token_complete boolean := false;<br />  l_line_complete boolean := false;<br />  l_new_token boolean := true;<br />  l_enclosed boolean := false;<br />  --<br />  l_lineno number := 1;<br />  l_columnno number := 1;<br /> <br />  -- additions from Kris<br />  l_ret t_csv_COL;<br />  l_ret_row t_csv_table;<br />  l_ret_index number;<br />begin<br />  -- initialize things<br />  l_ret := t_csv_COL();<br />  l_ret.extend;<br />  l_ret_row := t_csv_table(null,null,null,null,null,null,null,null,null,null);<br />  loop<br />    -- increment position index<br />    l_pos := l_pos + 1;<br /> <br />    -- get next character from clob<br />    l_char := dbms_lob.substr( p_clob, 1, l_pos);<br /> <br />    -- exit when no more characters to process<br />    exit when l_char is null or l_pos &gt; dbms_lob.getLength( p_clob );<br /> <br />    -- if first character of new token is optionally enclosed character<br />    -- note that and skip it and get next character<br />    if l_new_token and l_char = p_optionally_enclosed then<br />      l_enclosed := true;<br />      l_pos := l_pos + 1;<br />      l_char := dbms_lob.substr( p_clob, 1, l_pos);<br />    end if;<br />    l_new_token := false;<br /> <br />    -- get look ahead character<br />    l_lookahead := dbms_lob.substr( p_clob, 1, l_pos+1 );<br /> <br />    -- inspect character (and lookahead) to determine what to do<br />    if l_char = p_optionally_enclosed and l_enclosed then<br /> <br />      if l_lookahead = p_optionally_enclosed then<br />        l_pos := l_pos + 1;<br />        l_token := l_token || l_lookahead;<br />      elsif l_lookahead = p_delim then<br />        l_pos := l_pos + 1;<br />        l_token_complete := true;<br />      else<br />        l_enclosed := false;<br />      end if;<br /> <br />    elsif l_char in ( CARRIAGE_RETURN, LINE_FEED ) and NOT l_enclosed then<br />      l_token_complete := true;<br />      l_line_complete := true;<br /> <br />      if l_lookahead in ( CARRIAGE_RETURN, LINE_FEED ) then<br />        l_pos := l_pos + 1;<br />      end if;<br /> <br />    elsif l_char = p_delim and not l_enclosed then<br />      l_token_complete := true;<br /> <br />    elsif l_pos = dbms_lob.getLength( p_clob ) then<br />      l_token := l_token || l_char;<br />      l_token_complete := true;<br />      l_line_complete := true;<br /> <br />    else<br />      l_token := l_token || l_char;<br />    end if;<br />           <br />    -- process a new token<br />    if l_token_complete then<br />      -- dbms_output.put_line( 'R' || l_lineno || 'C' || l_columnno || ': ' || nvl(l_token,'**null**') );<br />       -- assign the column value<br />      case  l_columnno <br />          when 1 then  l_ret_row.col1 := l_token;<br />          when 2 then  l_ret_row.col2 := l_token;<br />          when 3 then  l_ret_row.col3 := l_token;<br />          when 4 then  l_ret_row.col4 := l_token;          <br />          when 5 then  l_ret_row.col5 := l_token;<br />          when 6 then  l_ret_row.col6 := l_token;<br />          when 7 then  l_ret_row.col7 := l_token;          <br />          when 8 then  l_ret_row.col8 := l_token;<br />          when 9 then  l_ret_row.col9 := l_token;<br />          when 10 then l_ret_row.col10 := l_token;<br />          else dbms_output.put_line('Only supports up to 10:'||l_columnno);<br />      end case;<br />                            <br />      l_columnno := l_columnno + 1;<br />      l_token := null;<br />      l_enclosed := false;<br />      l_new_token := true;<br />      l_token_complete := false;<br />    end if;<br /> <br />    -- process end-of-line here<br />    if l_line_complete then<br />      l_ret(l_lineno):= l_ret_row;<br />      l_lineno := l_lineno + 1;<br />      l_columnno := 1;<br />      l_line_complete := false;<br />      l_ret.extend;<br />      l_ret_row := t_csv_table(null,null,null,null,null,null,null,null,null,null);<br /><br />    end if;<br />  end loop;<br />  return l_ret;<br />end parse_csv;<br />/<br />show errors<br /><br /></pre><br /><br /><br />